@Article{Moore:1965,
author = {Moore, Gordon E.},
title = {Cramming more components onto integrated circuits},
year = 1965,
journal = {Proceedings of the IEEE},
volume = 86,
number = 1,
pages = {82--85},
}

@online{Larabel:2020,
title = {The Linux Kernel Enters 2020 At 27.8 Million Lines In Git But With Less Developers For 2019},
author = {Michael Larabel},
year = {2020},
url = {https://www.phoronix.com/news/Linux-Git-Stats-EOY2019},
}

@online{Claburn:2025,
title = {Mixing Rust and C in Linux likened to cancer by kernel maintainer},
author = {Claburn, Thomas.},
year = 2025,
url = {https://www.theregister.com/2025/02/05/mixing_rust_and_c_linux/},
}

@article{SwiftEtAl:2006,
author = {Swift, Michael M. and Annamalai, Muthukaruppan and Bershad, Brian N. and Levy, Henry M.},
title = {Recovering device drivers},
year = {2006},
issue_date = {November 2006},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {24},
number = {4},
issn = {0734-2071},
url = {https://doi.org/10.1145/1189256.1189257},
doi = {10.1145/1189256.1189257},
abstract = {This article presents a new mechanism that enables applications to run correctly when device drivers fail. Because device drivers are the principal failing component in most systems, reducing driver-induced failures greatly improves overall reliability. Earlier work has shown that an operating system can survive driver failures [Swift et al. 2005], but the applications that depend on them cannot. Thus, while operating system reliability was greatly improved, application reliability generally was not.To remedy this situation, we introduce a new operating system mechanism called a shadow driver. A shadow driver monitors device drivers and transparently recovers from driver failures. Moreover, it assumes the role of the failed driver during recovery. In this way, applications using the failed driver, as well as the kernel itself, continue to function as expected.We implemented shadow drivers for the Linux operating system and tested them on over a dozen device drivers. Our results show that applications and the OS can indeed survive the failure of a variety of device drivers. Moreover, shadow drivers impose minimal performance overhead. Lastly, they can be introduced with only modest changes to the OS kernel and with no changes at all to existing device drivers.},
journal = {ACM Trans. Comput. Syst.},
month = nov,
pages = {333–360},
numpages = {28},
keywords = {I/O, Recovery, device drivers}
}

@article{ChouEtAl:2001,
author = {Chou, Andy and Yang, Junfeng and Chelf, Benjamin and Hallem, Seth and Engler, Dawson},
title = {An empirical study of operating systems errors},
year = {2001},
issue_date = {Dec. 2001},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {35},
number = {5},
issn = {0163-5980},
url = {https://doi.org/10.1145/502059.502042},
doi = {10.1145/502059.502042},
abstract = {We present a study of operating system errors found by automatic, static, compiler analysis applied to the Linux and OpenBSD kernels. Our approach differs from previous studies that consider errors found by manual inspection of logs, testing, and surveys because static analysis is applied uniformly to the entire kernel source, though our approach necessarily considers a less comprehensive variety of errors than previous studies. In addition, automation allows us to track errors over multiple versions of the kernel source to estimate how long errors remain in the system before they are fixed.We found that device drivers have error rates up to three to seven times higher than the rest of the kernel. We found that the largest quartile of functions have error rates two to six times higher than the smallest quartile. We found that the newest quartile of files have error rates up to twice that of the oldest quartile, which provides evidence that code "hardens" over time. Finally, we found that bugs remain in the Linux kernel an average of 1.8 years before being fixed.},
journal = {SIGOPS Oper. Syst. Rev.},
month = oct,
pages = {73–88},
numpages = {16}
}

@article{LevinEtAl:1975,
author = {Levin, R. and Cohen, E. and Corwin, W. and Pollack, F. and Wulf, W.},
title = {Policy/mechanism separation in Hydra},
year = {1975},
issue_date = {November 1975},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {9},
number = {5},
issn = {0163-5980},
url = {https://doi.org/10.1145/1067629.806531},
doi = {10.1145/1067629.806531},
abstract = {The extent to which resource allocation policies are entrusted to user-level software determines in large part the degree of flexibility present in an operating system. In Hydra the determination to separate mechanism and policy is established as a basic design principle and is implemented by the construction of a kernel composed (almost) entirely of mechanisms. This paper presents three such mechanisms (scheduling, paging, protection) and examines how external policies which manipulate them may be constructed. It is shown that the policy decisions which remain embedded in the kernel exist for the sole purpose of arbitrating conflicting requests for physical resources, and then only to the extent of guaranteeing fairness.},
journal = {SIGOPS Oper. Syst. Rev.},
month = nov,
pages = {132–140},
numpages = {9},
keywords = {Mechanism, Operating system, Paging, Policy, Protection, Resource allocation, Scheduling}
}

@inproceedings{10.1145/800213.806531,
author = {Levin, R. and Cohen, E. and Corwin, W. and Pollack, F. and Wulf, W.},
title = {Policy/mechanism separation in Hydra},
year = {1975},
isbn = {9781450378635},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/800213.806531},
doi = {10.1145/800213.806531},
abstract = {The extent to which resource allocation policies are entrusted to user-level software determines in large part the degree of flexibility present in an operating system. In Hydra the determination to separate mechanism and policy is established as a basic design principle and is implemented by the construction of a kernel composed (almost) entirely of mechanisms. This paper presents three such mechanisms (scheduling, paging, protection) and examines how external policies which manipulate them may be constructed. It is shown that the policy decisions which remain embedded in the kernel exist for the sole purpose of arbitrating conflicting requests for physical resources, and then only to the extent of guaranteeing fairness.},
booktitle = {Proceedings of the Fifth ACM Symposium on Operating Systems Principles},
pages = {132–140},
numpages = {9},
keywords = {Mechanism, Operating system, Paging, Policy, Protection, Resource allocation, Scheduling},
location = {Austin, Texas, USA},
series = {SOSP '75}
}

@article{SaltzerEtAl:1973,
author = {Saltzer, Jerome H.},
title = {Protection and control of information sharing in multics},
year = {1973},
issue_date = {October 1973},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {7},
number = {4},
issn = {0163-5980},
url = {https://doi.org/10.1145/957195.808059},
doi = {10.1145/957195.808059},
abstract = {This paper describes the design of mechanisms to control sharing of information in the Multics system. Seven design principles help provide insight into the tradeoffs among different possible designs. The key mechanisms described include access control lists, hierarchical control of access specifications, identification and authentication of users, and primary memory protection. The paper ends with a discussion of several known weaknesses in the current protection mechanism design.},
journal = {SIGOPS Oper. Syst. Rev.},
month = jan,
pages = {119},
numpages = {1}
}

@inproceedings{10.1145/800009.808059,
author = {Saltzer, Jerome H.},
title = {Protection and control of information sharing in multics},
year = {1973},
isbn = {9781450373746},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/800009.808059},
doi = {10.1145/800009.808059},
abstract = {This paper describes the design of mechanisms to control sharing of information in the Multics system. Seven design principles help provide insight into the tradeoffs among different possible designs. The key mechanisms described include access control lists, hierarchical control of access specifications, identification and authentication of users, and primary memory protection. The paper ends with a discussion of several known weaknesses in the current protection mechanism design.},
booktitle = {Proceedings of the Fourth ACM Symposium on Operating System Principles},
pages = {119},
series = {SOSP '73}
}

@online{LinuxSyscalls:2024,
title = {syscalls(2) - Linux manual page},
year = 2024,
url = {https://man7.org/linux/man-pages/man2/syscalls.2.html},
}

@article{DennisEtAl:1966,
author = {Dennis, Jack B. and Van Horn, Earl C.},
title = {Programming semantics for multiprogrammed computations},
year = {1966},
issue_date = {March 1966},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {9},
number = {3},
issn = {0001-0782},
url = {https://doi.org/10.1145/365230.365252},
doi = {10.1145/365230.365252},
abstract = {The semantics are defined for a number of meta-instructions which perform operations essential to the writing of programs in multiprogrammed computer systems. These meta-instructions relate to parallel processing, protecting of separate computations, program debugging, and the sharing among users of memory segments and other computing objects, the names of which are hierarchically structured. The language sophistication contemplated is midway between an assembly language and an advanced algebraic language.},
journal = {Commun. ACM},
month = mar,
pages = {143–155},
numpages = {13}
}

